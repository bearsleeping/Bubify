<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Bubfiy</title>

<!-- Ustawienia dla aplikacji webowej na iOS (ukrycie paska przeglądarki) -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Bubify">
<link rel="apple-touch-icon" href="images/apple-touch-icon.png"> <!-- Zastąp ścieżką do Twojej ikony (np. 180x180px) -->

<!-- Import czcionki z Google Fonts -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">

<!-- Spotify Web Playback SDK -->
<script src="https://sdk.scdn.co/spotify-player.js"></script>

<style>
:root {
    --bg-color: #110f0f;
    --primary: #0a58a3; /* Ciemniejszy, bardziej stonowany niebieski */
    --primary-hover: #084680; /* Ciemniejszy niebieski dla hover */
    --text-primary: #ffffff;
    --text-secondary: #98989d;
    --control-bg: #3a3a3c;
    --card-bg: #2c2c2e;
    /* Nowe zmienne dla przycisków i list */
    --control-btn-bg: rgba(255, 255, 255, 0.08);
    --control-btn-bg-hover: rgba(255, 255, 255, 0.16);
    --control-btn-bg-active: rgba(255, 255, 255, 0.12);
    --divider-color: rgba(255, 255, 255, 0.1);
    --list-item-hover-bg: rgba(255, 255, 255, 0.05);
}

/* Gothic Vampire Theme */
body.theme-vampire {
    /* --- Tło w postaci obrazu --- */

    --bg-color: #180000;
    --primary: #6d0000; /* Ciemniejsza, głębsza czerwień */
    --primary-hover: #5c0000; /* Ciemniejsza czerwień dla hover */
    --text-primary: #f5f5f5;
    --text-secondary: #a0a0a0;
    --control-bg: #333333;
    --card-bg: #1e1e1e;
    /* Nowe zmienne dla przycisków i list */
    --control-btn-bg: rgba(255, 255, 255, 0.08);
    --control-btn-bg-hover: rgba(255, 255, 255, 0.16);
    --control-btn-bg-active: rgba(255, 255, 255, 0.12);
    --divider-color: rgba(255, 255, 255, 0.1);
    --list-item-hover-bg: rgba(255, 255, 255, 0.05);
}
* { margin:0; padding:0; box-sizing:border-box; font-family:-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; -webkit-tap-highlight-color: transparent; /* Usunięcie podświetlenia przy dotyku na iOS */ }
body {
    background-color: var(--bg-color); color: var(--text-primary);
    max-width:400px; margin:0 auto;
    height: 100vh; /* Fallback dla przeglądarek bez JS */
    height: calc(var(--vh, 1vh) * 100); /* Poprawka na problem 100vh na mobile */
    display:flex; flex-direction:column;
    overflow:hidden; position:relative; 
    transition: background-color 0.4s ease, color 0.4s ease;
}
/* Pseudo-element do płynnego przejścia tła obrazkowego */
body::after {
    content: '';
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background-image: url('images/vampire-bg.jpg');
    background-size: cover;
    background-position: center;
    background-attachment: fixed;
    opacity: 0;
    filter: blur(0px); /* Dodajemy filtr rozmycia */
    transition: opacity 0.4s ease, filter 0.4s ease; /* Dodajemy przejście dla filtra */
    z-index: -1; /* Umieść za treścią */
    pointer-events: none;
}
body.theme-vampire::after {
    opacity: 1;
    filter: blur(5px); /* Ustawiamy rozmycie dla motywu wampira */
}
.header { padding:15px 20px; display: flex; justify-content: space-between; align-items: center; font-size:18px; font-weight:600; letter-spacing:-0.5px; transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out; position: relative; z-index: 2; }
.header > span {
    font-family: 'Pacifico', cursive;
    font-size: 24px;
    font-weight: 400; /* Czcionki ozdobne często wyglądają lepiej bez pogrubienia */
    transform: translateY(2px); /* Delikatne dopasowanie pionowe */
}
.theme-switcher {
    cursor: pointer;
    color: var(--text-secondary);
    transition: color 0.2s, transform 0.1s ease-out;
}
.header-actions {
    display: flex;
    align-items: center;
    gap: 15px;
}
#login-spotify-btn {
    background: none;
    border: none;
    cursor: pointer;
    color: var(--text-secondary);
    transition: color 0.2s, transform 0.1s ease-out;
}
.theme-switcher:hover {
    color: var(--text-primary);
}
.theme-switcher:active {
    transform: scale(0.9);
}
.now-playing { flex:1; display:flex; flex-direction:column; align-items:center; justify-content:center; padding:0 30px; transition: transform 0.3s ease-in-out; position: relative; z-index: 2; }
.album-cover { width:280px; height:280px; border-radius:50%; box-shadow:0 4px 30px rgba(0,0,0,0.5); position:relative; margin-bottom:30px; background:#1a1a1a; display:flex; align-items:center; justify-content:center; background-image: repeating-radial-gradient(circle at center, rgba(255,255,255,0.03) 0, rgba(255,255,255,0.03) 1px, transparent 1px, transparent 4px); cursor: grab; transition: box-shadow 0.7s ease-in-out; }
.album-cover::before { content:''; position:absolute; width:20px; height:20px; background:var(--bg-color); border-radius:50%; z-index:2; border:3px solid var(--control-bg); transition: background-color 0.4s ease, border-color 0.4s ease; }
.album-cover img { width:100px; height:100px; object-fit:cover; border-radius:50%; z-index:1; }
.song-info { text-align:center; margin-bottom:30px; width:100%; }
.song-title { font-size:22px; font-weight:600; margin-bottom:4px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
.song-artist { font-size:16px; color:var(--text-secondary); transition: color 0.3s ease; }
.progress-container { width:100%; margin-bottom:15px; }
.progress-bar {
    width: 100%;
    height: 5px; /* Zwiększony obszar dotykowy dla łatwiejszej obsługi */
    background-color: transparent;
    margin-bottom: 5px;
    cursor: pointer;
    position: relative; /* Potrzebne dla pseudo-elementu i paska postępu */
}
/* Rysowanie tła (ścieżki) jako pseudo-element, aby nie kolidowało z obszarem dotykowym */
.progress-bar::before {
    content: '';
    position: absolute;
    left: 0;
    top: 50%;
    transform: translateY(-50%);
    width: 100%;
    height: 3px;
    background-color: var(--control-bg); transition: background-color 0.4s ease;
    border-radius: 3px;
    pointer-events: none; /* Ignoruj zdarzenia myszy na tym elemencie */
}
.progress {
    position: absolute;
    left: 0;
    top: 50%;
    transform: translateY(-50%);
    height: 3px; /* Stała wysokość wizualnego paska */
    background-color: var(--primary);
    border-radius: 3px;
    width: 0%;
    transition: width 0.1s linear, background-color 0.4s ease;
    pointer-events: none; /* Ignoruj zdarzenia myszy na tym elemencie */
}
.time { display:flex; justify-content:space-between; font-size:12px; color:var(--text-secondary); transition: color 0.4s ease; }
.volume-container {
    width: 100%;
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 25px;
}
.volume-container svg {
    fill: var(--text-secondary);
    flex-shrink: 0; transition: fill 0.4s ease;
}
.volume-slider {
    -webkit-appearance: none;
    appearance: none;
    width: 100%;
    height: 24px; /* Zwiększona wysokość dla łatwiejszej interakcji na dotyku */
    background: transparent; /* Tło jest teraz na ścieżce */
    outline: none;
    cursor: pointer;
}
.volume-slider::-webkit-slider-runnable-track {
    width: 100%;
    height: 3px; /* Bardzo cienka ścieżka w stylu iOS */
    cursor: pointer;
    background: linear-gradient(to right, var(--text-primary) var(--volume-progress, 100%), var(--control-bg) var(--volume-progress, 100%));
    border-radius: 2px;
}
.volume-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 15px; /* Przywrócenie kciuka dla interaktywności */
    height: 15px;
    background: var(--text-primary);
    border-radius: 50%;
    cursor: pointer;
    margin-top: -6px; /* Wyśrodkowanie kciuka na ścieżce (3px - 15px) / 2 */
    transition: transform 0.15s ease-in-out, background-color 0.4s ease;
}
.volume-slider:active::-webkit-slider-thumb {
    transform: scale(1.2); /* Powiększenie kciuka podczas przeciągania */
}

/* Style dla Firefox */
.volume-slider::-moz-range-track {
    width: 100%;
    height: 3px;
    cursor: pointer;
    background: var(--control-bg);
    border-radius: 2px;
}
.volume-slider::-moz-range-progress {
    background-color: var(--text-primary);
    height: 3px;
    border-radius: 2px;
}
.volume-slider::-moz-range-thumb {
    width: 15px;
    height: 15px;
    background: var(--text-primary);
    border-radius: 50%;
    cursor: pointer;
    border: none;
    transition: transform 0.15s ease-in-out, background-color 0.4s ease;
}
.volume-slider:active::-moz-range-thumb {
    transform: scale(1.2);
} /* Wielkość przycisków to 18px */
.controls { display:flex; justify-content:center; align-items:center; gap: 18px; margin-bottom:30px; }
.control-btn { width:48px; height:48px; display:flex; align-items:center; justify-content:center; border-radius:50%; cursor:pointer; background-color: var(--control-btn-bg); transition: background-color 0.4s ease, transform 0.1s ease-out; }
.control-btn:hover { background-color: var(--control-btn-bg-hover); }
.control-btn:active {
    transform: scale(0.9);
    background-color: var(--control-btn-bg-active);
}
.control-btn svg { fill: var(--text-primary); transition: fill 0.4s ease; }
.control-btn.active svg { fill: var(--primary); }
.repeat-btn .icon-repeat-one { display: none; }
.play-btn { width:70px; height:70px; background-color: var(--primary); transition: background-color 0.4s ease, transform 0.1s ease-out; }
.play-btn .icon-pause { display: none; } 
.play-btn:hover { background-color: var(--primary-hover); }
.playing .play-btn .icon-play {
    display: none;
}
.playing .play-btn .icon-pause {
    display: block;
}
.player-footer { background-color:var(--card-bg); border-top-left-radius:35px; border-top-right-radius:15px; box-shadow:0 -5px 15px rgba(0,0,0,0.3); position:absolute; bottom:0; left:0; right:0; transform: translateY(calc(100% + 20px)); transition: transform 0.3s ease-in-out, background-color 0.4s ease; display: flex; flex-direction: column; max-height: 520px; z-index: 2; }
.playlist-header { padding: 15px 20px; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--control-bg); flex-shrink: 0; transition: border-color 0.4s ease; }
.playlist-title { font-size: 18px; font-weight: 600; }
.manage-playlists-btn { background: none; border: 1px solid var(--text-secondary); color: var(--text-secondary); padding: 5px 10px; border-radius: 15px; cursor: pointer; display: flex; align-items: center; gap: 5px; font-size: 13px; transition: all 0.2s; }
.manage-playlists-btn:hover { background-color: var(--control-bg); color: var(--text-primary); border-color: var(--control-bg); }
.manage-playlists-btn svg { fill: currentColor; width: 16px; height: 16px; }
.song-list { list-style:none; overflow-y:auto; padding: 0 20px 35px; flex-grow: 1; }
.song-item { display:flex; align-items:center; padding:10px 0; border-bottom:1px solid var(--divider-color); transition: background-color 0.2s, border-color 0.4s ease; gap: 15px; }
.song-item:hover { background-color: var(--list-item-hover-bg); }
.song-item:last-child { border-bottom:none; }
.song-number { color:var(--text-secondary); font-size:14px; width:30px; text-align:center; }
.song-thumbnail { width:40px; height:40px; border-radius:5px; overflow:hidden; margin-right:15px; }
.song-thumbnail img { width:100%; height:100%; object-fit:cover; }
.song-item-info { flex:1; cursor: pointer; min-width: 0; }
.song-item-title { font-size:15px; margin-bottom:2px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; transition: color 0.4s ease; }
.song-item-artist { font-size:13px; color:var(--text-secondary); }
.song-item.active .song-item-title {
    color: var(--primary);
}
.song-item-duration { font-size:13px; color:var(--text-secondary); }
.song-item-actions { margin-left: auto; padding-left: 10px; }
.favorite-btn { background: none; border: none; cursor: pointer; padding: 5px; display: flex; align-items: center; justify-content: center; }
.favorite-btn svg { stroke: var(--text-secondary); fill: none; transition: all 0.2s; }
.favorite-btn:hover svg { stroke: var(--primary); }
.favorite-btn .icon-heart-filled { display: none; }
.favorite-btn.is-favorite .icon-heart-empty { display: none; }
.favorite-btn.is-favorite .icon-heart-filled { display: block; fill: var(--primary); }
.song-list::-webkit-scrollbar { width:5px; }
.song-list::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); border-radius:10px; }
.song-list::-webkit-scrollbar-thumb { background:var(--text-secondary); border-radius:10px; }
@media (max-height:700px) { .album-cover { width:220px; height:220px; } }

/* Nowe style do animacji wysuwania kolejki */
body.queue-open .header {
    transform: translateY(-100%);
    opacity: 0;
    pointer-events: none;
}
body.queue-open .player-footer {
    transform: translateY(0);
}
body.queue-open .now-playing {
    transform: translateY(-520px);
}
body.scrubbing {
    cursor: grabbing;
}

/* Ukrywanie suwaka głośności tylko na urządzeniach z systemem iOS */
body.is-ios .volume-container {
    display: none;
}

/* Efekt specjalny dla Type O Negative */
.album-cover.type-o-negative-glow {
    box-shadow: 0 4px 35px rgba(0,0,0,0.6), 0 0 80px 15px rgba(80, 220, 0, 0.5);
}

/* Efekt specjalny dla Rammstein */
.album-cover.rammstein-glow {
    box-shadow: 0 4px 35px rgba(0,0,0,0.6), 0 0 80px 15px rgba(255, 0, 0, 0.5);
}

/* Playlist Manager View */
.playlist-manager-view {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: var(--bg-color);
    z-index: 110; /* Above lyrics view */
    transform: translateY(100%);
    transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1), background-color 0.4s ease;
    display: flex;
    flex-direction: column;
}
body.playlist-manager-open .playlist-manager-view {
    transform: translateY(0);
}
.playlist-manager-header {
    padding: 15px 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 18px;
    font-weight: 600;
    flex-shrink: 0;
    border-bottom: 1px solid var(--control-bg);
    transition: border-color 0.4s ease;
}
.playlist-manager-list {
    list-style: none;
    padding: 10px;
    overflow-y: auto;
}
.playlist-manager-item {
    padding: 15px 20px;
    font-size: 18px;
    border-bottom: 1px solid var(--control-bg);
    cursor: pointer;
    transition: background-color 0.2s, border-color 0.4s ease, color 0.4s ease;
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.playlist-manager-header-actions {
    display: flex;
    align-items: center;
    gap: 10px;
}
.create-playlist-btn, .close-playlist-manager-btn {
    background: none;
    border: none;
    cursor: pointer;
    padding: 5px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
}
.create-playlist-btn svg, .close-playlist-manager-btn svg {
    fill: var(--text-secondary);
    transition: fill 0.2s;
}
.create-playlist-btn:hover svg, .close-playlist-manager-btn:hover svg {
    fill: var(--text-primary);
}
.delete-playlist-btn {
    background: none;
    border: none;
    cursor: pointer;
    padding: 5px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    opacity: 0;
    transition: opacity 0.2s, background-color 0.2s;
}
.playlist-manager-item:hover .delete-playlist-btn {
    opacity: 1;
}
.delete-playlist-btn svg {
    width: 18px;
    height: 18px;
    fill: var(--text-secondary);
    transition: fill 0.2s;
}
.delete-playlist-btn:hover {
    background-color: rgba(255, 69, 58, 0.15);
}
.delete-playlist-btn:hover svg {
    fill: #ff453a; /* iOS red */
}
.playlist-manager-item:hover {    
    background-color: var(--list-item-hover-bg);
}
.playlist-manager-item.active {
    color: var(--primary);
    font-weight: 600;
}

/* Modal (Pop-up) Styles */
.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(0, 0, 0, 0.6);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 200;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease, visibility 0s linear 0.3s;
}
.modal-overlay.visible {
    opacity: 1;
    visibility: visible;
    transition: opacity 0.3s ease;
}
.modal {
    background-color: var(--card-bg);
    padding: 20px;
    border-radius: 14px;
    width: calc(100% - 40px);
    max-width: 320px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    transform: scale(0.95);
    transition: transform 0.3s ease, background-color 0.4s ease;
}
.modal-overlay.visible .modal {
    transform: scale(1);
}
.modal-title {
    font-size: 18px;
    font-weight: 600;
    text-align: center;
    margin-bottom: 8px;
}
.modal-description {
    font-size: 14px;
    color: var(--text-secondary);
    text-align: center;
    margin-bottom: 20px;
}
.modal input[type="text"] {
    width: 100%;
    padding: 12px;
    border-radius: 8px;
    border: 1px solid var(--control-bg);
    background-color: var(--bg-color);
    color: var(--text-primary);
    font-size: 16px;
    margin-bottom: 20px;
    outline: none;
    -webkit-user-select: auto; /* Allow text selection in input */
    -moz-user-select: auto;
    -ms-user-select: auto;
    user-select: auto;
}
.modal input[type="text"]:focus {
    border-color: var(--primary);
    box-shadow: 0 0 0 2px rgba(10, 132, 255, 0.3);
}
.modal-actions {
    display: flex;
    gap: 10px;
}
.modal-actions button {
    flex: 1;
    padding: 12px;
    border: none;
    border-radius: 8px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: background-color 0.4s ease, color 0.4s ease, transform 0.1s;
}
.modal-actions button:active {
    transform: scale(0.98);
}
.modal-btn-primary {
    background-color: var(--primary);
    color: white;
}
.modal-btn-primary:hover {
    background-color: var(--primary-hover);
}
.modal-btn-secondary {
    background-color: var(--control-bg);
    color: var(--text-primary);
}
.modal-btn-secondary:hover {
    background-color: #4a4a4c; /* Slightly lighter control bg */
}

@media (min-width: 800px) {
    .song-list {
        padding: 0 10px 20px 10px;
    }
}
</style>
</head>
<body class="theme-vampire">
<div class="header">
    <span>Bubify</span>
    <div class="header-actions">
        <button id="login-spotify-btn" title="Zaloguj się z Spotify">
            <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="currentColor">
                <path d="M12 0C5.373 0 0 5.373 0 12s5.373 12 12 12 12-5.373 12-12S18.627 0 12 0zm5.923 17.46c-.225.352-.674.465-.923.243-2.58-1.58-5.83-1.94-9.702-1.06-.38.09-.676-.18-.765-.554s.18-.675.554-.765c4.22-1.02 7.79-.6 10.68 1.22.26.18.33.57.15.856zm1.23-2.73c-.28.43-.84.56-1.27.28-2.95-1.8-7.33-2.3-10.78-1.25-.46.14-.98-.12-1.12-.58-.14-.46.12-.98.58-1.12C11.27 10.85 16.1 11.4 19.4 13.5c.4.25.53.8.28 1.23zm.12-3.12c-3.5-2.1-9.1-2.5-12.6-.14-.55.21-1.17-.15-1.38-.7s.15-1.17.7-1.38c4.02-1.58 10.22-1.1 14.23 1.4.5.3.68.95.38 1.45s-.95.68-1.45.37z"/>
            </svg>
        </button>
        <div class="theme-switcher" id="theme-switcher"><svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg></div>
    </div>
</div>
<div class="now-playing">
<div class="album-cover">
<img src="https://placehold.co/100x100/2c2c2e/ffffff?text=?" alt="Okładka albumu" />
</div>
<div class="song-info">
<div class="song-title">Zaloguj się przez Spotify</div>
<div class="song-artist">aby wczytać muzykę</div>
</div>
<div class="progress-container">
<div class="progress-bar">
<div class="progress" id="progress"></div>
</div>
<div class="time">
<span id="current-time">0:00</span>
<span id="duration">0:00</span>
</div>
</div>
<div class="volume-container">
    <svg width="16" height="16" viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>
    <input type="range" id="volume-slider" class="volume-slider" min="0" max="100" value="100">
</div>
<div class="controls">
<div class="control-btn repeat-btn" id="repeat-btn">
<svg class="icon-repeat-all" width="24" height="24" viewBox="0 0 24 24"><path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4z"/></svg>
<svg class="icon-repeat-one" width="24" height="24" viewBox="0 0 24 24"><path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4zm-4-2V9h-1l-2 1v1h1.5v3H13z"/></svg>
</div>
<div class="control-btn prev-btn">
<svg width="18" height="18" viewBox="0 0 24 24"><path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/></svg>
</div>
<div class="control-btn play-btn" id="play-btn">
<svg class="icon-play" width="24" height="24" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
<svg class="icon-pause" width="24" height="24" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
</div>
<div class="control-btn next-btn">
<svg width="18" height="18" viewBox="0 0 24 24"><path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/></svg>
</div>
<div class="control-btn queue-btn">
<svg width="24" height="24" viewBox="0 0 24 24"><path d="M3 13h2v-2H3v2zm0 4h2v-2H3v2zm0-8h2V7H3v2zm4 4h14v-2H7v2zm0 4h14v-2H7v2zM7 7v2h14V7H7z"/></svg>
</div>
</div>
</div>
<div class="player-footer">
<div class="playlist-header">
    <h2 class="playlist-title">Wszystkie utwory</h2>
    <button class="manage-playlists-btn">
        <svg width="24" height="24" viewBox="0 0 24 24"><path d="M4 6h16v2H4zm0 5h16v2H4zm0 5h16v2H4z"/></svg>
        <span>Playlisty</span>
    </button>
</div>
<ul class="song-list" id="song-list">
</ul>
</div>
<div class="playlist-manager-view">
    <div class="playlist-manager-header">
        <span>Wybierz playlistę</span>
        <div class="playlist-manager-header-actions">
            <button class="create-playlist-btn" title="Utwórz nową playlistę">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
            </button>
            <div class="close-playlist-manager-btn">
                <svg width="24" height="24" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
            </div>
        </div>
    </div>
    <ul class="playlist-manager-list" id="playlist-manager-list">
    </ul>
</div>

<div class="modal-overlay" id="create-playlist-modal-overlay">
    <div class="modal">
        <h3 class="modal-title">Nowa playlista</h3>
        <p class="modal-description">Wprowadź nazwę dla swojej nowej playlisty.</p>
        <input type="text" id="new-playlist-name-input" placeholder="np. Wieczorne granie">
        <div class="modal-actions">
            <button class="modal-btn-secondary" id="cancel-create-playlist-btn">Anuluj</button>
            <button class="modal-btn-primary" id="confirm-create-playlist-btn">Utwórz</button>
        </div>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    // --- Poprawka na wysokość 100vh na urządzeniach mobilnych (np. iOS Safari) ---
    function setViewportHeight() {
        // Obliczamy 1% wysokości okna przeglądarki i ustawiamy jako zmienną CSS
        let vh = window.innerHeight * 0.01;
        document.documentElement.style.setProperty('--vh', `${vh}px`);
    }
    // Uruchom funkcję na starcie
    setViewportHeight();
    // Uruchom funkcję przy zmianie rozmiaru okna (np. obrót ekranu)
    window.addEventListener('resize', setViewportHeight);

    // --- Wykrywanie iOS i ukrywanie suwaka głośności ---
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    if (isIOS) {
        document.body.classList.add('is-ios');
    }

    const playBtn = document.getElementById('play-btn');
    const progress = document.getElementById('progress');
    const currentTimeEl = document.getElementById('current-time');
    const durationEl = document.getElementById('duration');
    const songListEl = document.getElementById('song-list');
    const queueBtn = document.querySelector('.queue-btn');
    const body = document.body;    
    const themeSwitcher = document.getElementById('theme-switcher');
    const volumeSlider = document.getElementById('volume-slider');
    const albumCover = document.querySelector('.album-cover');
    const progressBar = document.querySelector('.progress-bar');
    const repeatBtn = document.getElementById('repeat-btn');
    const iconRepeatAll = repeatBtn.querySelector('.icon-repeat-all');
    const iconRepeatOne = repeatBtn.querySelector('.icon-repeat-one');
    const playlistTitleEl = document.querySelector('.playlist-title');
    const managePlaylistsBtn = document.querySelector('.manage-playlists-btn');
    const playlistManagerView = document.querySelector('.playlist-manager-view');
    const closePlaylistManagerBtn = document.querySelector('.close-playlist-manager-btn');
    const playlistManagerList = document.getElementById('playlist-manager-list');
    const createPlaylistBtn = document.querySelector('.create-playlist-btn');
    // Nowe elementy modala
    const createPlaylistModalOverlay = document.getElementById('create-playlist-modal-overlay');
    const newPlaylistNameInput = document.getElementById('new-playlist-name-input');
    const confirmCreatePlaylistBtn = document.getElementById('confirm-create-playlist-btn');
    const cancelCreatePlaylistBtn = document.getElementById('cancel-create-playlist-btn');

    // --- Zmienne globalne dla Spotify ---
    let spotifyPlayer = null;
    let spotifyDeviceId = null;
    let spotifyAccessToken = null;
    // Elementy dla Spotify
    const loginSpotifyBtn = document.getElementById('login-spotify-btn');

    let isPlaying = false;
    let currentSongIndex = 0;
    const audio = new Audio();
    let currentRotation = 0;
    let animationFrameId = null;
    let repeatMode = 0; // 0: none, 1: all, 2: one

    // --- Nowa struktura danych dla playlist ---
    let allSongs = []; // Główna lista wszystkich obiektów piosenek
    let playlists = {}; // { "nazwa": [url1, url2], ... }
    let activePlaylistName = 'Wszystkie utwory';
    let songs = []; // Widok piosenek dla aktywnej playlisty

    // --- Logika dla Spotify ---

    // Zastąp tym ID klienta ze swojego panelu deweloperskiego Spotify
    const SPOTIFY_CLIENT_ID = 'cf0998cbebe04f34ba460cae3d80dc16'; 
    const SPOTIFY_REDIRECT_URI = 'https://bearsleeping.github.io/Bubify/';
    const SPOTIFY_SCOPES = [
        'streaming',
        'user-read-email',
        'user-read-private',
        'user-library-read',
        'user-library-modify',
        'user-read-playback-state',
        'user-modify-playback-state'
    ].join(' ');

    // --- Nowa, bezpieczna logika logowania (Authorization Code Flow with PKCE) ---

    // Funkcja do generowania losowego ciągu znaków dla code_verifier
    function generateRandomString(length) {
        let text = '';
        const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        for (let i = 0; i < length; i++) {
            text += possible.charAt(Math.floor(Math.random() * possible.length));
        }
        return text;
    }

    // Funkcja do generowania code_challenge na podstawie code_verifier
    async function generateCodeChallenge(codeVerifier) {
        const data = new TextEncoder().encode(codeVerifier);
        const digest = await window.crypto.subtle.digest('SHA-256', data);
        return btoa(String.fromCharCode.apply(null, [...new Uint8Array(digest)]))
            .replace(/\+/g, '-')
            .replace(/\//g, '_')
            .replace(/=+$/, '');
    }

    // 1. Przekierowanie do Spotify w celu uzyskania kodu autoryzacji
    loginSpotifyBtn.addEventListener('click', async () => {
        const codeVerifier = generateRandomString(128);
        const codeChallenge = await generateCodeChallenge(codeVerifier);

        // Zapisz codeVerifier w pamięci przeglądarki, aby użyć go po powrocie
        window.localStorage.setItem('spotify_code_verifier', codeVerifier);

        const authUrl = new URL("https://accounts.spotify.com/authorize");
        const params = {
            client_id: SPOTIFY_CLIENT_ID,
            response_type: 'code', // Zmienione z 'token' na 'code'
            redirect_uri: SPOTIFY_REDIRECT_URI,
            scope: SPOTIFY_SCOPES,
            code_challenge_method: 'S256',
            code_challenge: codeChallenge,
        };
        authUrl.search = new URLSearchParams(params).toString();
        window.location.href = authUrl.toString();
    });

    // 2. Wymiana kodu na token dostępowy po powrocie
    async function exchangeCodeForToken(code) {
        const codeVerifier = window.localStorage.getItem('spotify_code_verifier');

        const response = await fetch("https://accounts.spotify.com/api/token", {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: new URLSearchParams({
                client_id: SPOTIFY_CLIENT_ID,
                grant_type: 'authorization_code',
                code: code,
                redirect_uri: SPOTIFY_REDIRECT_URI,
                code_verifier: codeVerifier,
            }),
        });
        return await response.json();
    }

    function initializeSpotifyPlayer(token) { // Ta funkcja pozostaje bez zmian
        spotifyAccessToken = token;

        window.onSpotifyWebPlaybackSDKReady = () => {
            spotifyPlayer = new Spotify.Player({
                name: 'Bubify Web Player',
                getOAuthToken: cb => { cb(token); },
                volume: 0.5
            });

            // Error handling
            spotifyPlayer.addListener('initialization_error', ({ message }) => { console.error('Initialization Error:', message); });
            spotifyPlayer.addListener('authentication_error', ({ message }) => { 
                console.error('Authentication Error:', message);
                // Token mógł wygasnąć, przekieruj do logowania
                window.location.hash = ''; // Wyczyść stary token
                loginSpotifyBtn.click();
            });
            spotifyPlayer.addListener('account_error', ({ message }) => { console.error('Account Error:', message); alert('Błąd konta Spotify. Upewnij się, że używasz konta Premium.'); });
            spotifyPlayer.addListener('playback_error', ({ message }) => { console.error('Playback Error:', message); });

            // Playback status updates
            spotifyPlayer.addListener('player_state_changed', state => { 
                if (!state) { return; }
                console.log('Zmiana stanu odtwarzacza Spotify:', state);

                // Aktualizacja UI na podstawie stanu ze Spotify
                isPlaying = !state.paused;
                body.classList.toggle('playing', isPlaying);

                const progressMs = state.position;
                const durationMs = state.duration;
                const progressPercent = (durationMs > 0) ? (progressMs / durationMs) * 100 : 0;
                progress.style.width = `${progressPercent}%`;
                currentTimeEl.textContent = formatTime(progressMs / 1000);
                durationEl.textContent = formatTime(durationMs / 1000);

                // Możesz też zaktualizować info o piosence, jeśli zmieniła się w innej aplikacji
            });

            // Ready
            spotifyPlayer.addListener('ready', ({ device_id }) => {
                console.log('Odtwarzacz Spotify jest gotowy z ID urządzenia', device_id);
                spotifyDeviceId = device_id;
                // Dopiero teraz, gdy odtwarzacz jest gotowy, wczytaj utwory
                loadFromSpotify(spotifyAccessToken);
            });

            // Not Ready
            spotifyPlayer.addListener('not_ready', ({ device_id }) => {
                console.log('Urządzenie stało się niedostępne', device_id);
            });

            // Connect to the player!
            spotifyPlayer.connect().then(success => {
                if (success) {
                    console.log('Połączono z odtwarzaczem Spotify.');
                }
            });
        };
    }

    // --- Przełączanie i zapamiętywanie motywu ---
    function applyTheme(theme) {
        // Domyślnie jest motyw standardowy (bez dodatkowej klasy)
        if (theme === 'vampire') {
            body.classList.add('theme-vampire');
        } else {
            body.classList.remove('theme-vampire');
        }
    }

    themeSwitcher.addEventListener('click', () => {
        const isVampire = body.classList.contains('theme-vampire');
        const newTheme = isVampire ? 'default' : 'vampire';
        applyTheme(newTheme);
        localStorage.setItem('musicPlayerTheme', newTheme);
    });

    // Zastosuj motyw zapisany w pamięci przy starcie aplikacji
    applyTheme(localStorage.getItem('musicPlayerTheme'));

    function formatTime(seconds) {
        const minutes = Math.floor(seconds / 60);
        let secs = Math.floor(seconds % 60);
        if (secs < 10) {
            secs = '0' + secs;
        }
        return `${minutes}:${secs}`;
    }

    // --- Zarządzanie playlistami ---
    function loadPlaylists() {
        const storedPlaylists = localStorage.getItem('bubify_playlists');
        if (storedPlaylists) {
            playlists = JSON.parse(storedPlaylists);
        } else {
            playlists = { 'Ulubione': [] };
        }
        // 'Wszystkie utwory' jest efemeryczna i zawsze tworzona od nowa
        playlists['Wszystkie utwory'] = [];
    }

    function savePlaylists() {
        const playlistsToSave = { ...playlists };
        // Nie zapisujemy auto-generowanej playlisty
        delete playlistsToSave['Wszystkie utwory'];
        localStorage.setItem('bubify_playlists', JSON.stringify(playlistsToSave));
    }

    function togglePlaylistManager() {
        body.classList.toggle('playlist-manager-open');
    }

    function createPlaylist() {
        newPlaylistNameInput.value = ''; // Wyczyść poprzednią wartość
        createPlaylistModalOverlay.classList.add('visible');
        // Małe opóźnienie dla focus, aby zadziałał po tym jak modal stanie się widoczny
        setTimeout(() => newPlaylistNameInput.focus(), 50);
    }

    function hideCreatePlaylistModal() {
        createPlaylistModalOverlay.classList.remove('visible');
    }

    function handleConfirmCreatePlaylist() {
        const name = newPlaylistNameInput.value;
        if (name && name.trim() !== '') {
            const trimmedName = name.trim();
            if (playlists[trimmedName]) {
                alert('Playlista o tej nazwie już istnieje!'); // To też można by zamienić na ładniejszy alert w przyszłości
            } else {
                playlists[trimmedName] = [];
                savePlaylists();
                populatePlaylistManager();
                hideCreatePlaylistModal();
            }
        } else {
            // Opcjonalnie: pokaż błąd, jeśli nazwa jest pusta
            alert('Nazwa playlisty nie może być pusta.');
        }
    }

    function deletePlaylist(name) {
        if (confirm(`Czy na pewno chcesz usunąć playlistę "${name}"? Tej operacji nie można cofnąć.`)) {
            if (activePlaylistName === name) {
                setActivePlaylist('Wszystkie utwory');
            }
            delete playlists[name];
            savePlaylists();
            populatePlaylistManager();
        }
    }

    function populatePlaylistManager() {
        playlistManagerList.innerHTML = '';
        Object.keys(playlists).forEach(name => {
            const li = document.createElement('li');
            li.classList.add('playlist-manager-item');
            
            const nameSpan = document.createElement('span');
            nameSpan.textContent = name;
            li.appendChild(nameSpan);

            if (name === activePlaylistName) li.classList.add('active');

            // Dodaj przycisk usuwania dla playlist, które można usunąć
            if (name !== 'Wszystkie utwory' && name !== 'Ulubione') {
                const deleteBtn = document.createElement('button');
                deleteBtn.classList.add('delete-playlist-btn');
                deleteBtn.title = `Usuń playlistę "${name}"`;
                deleteBtn.innerHTML = `<svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>`;
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Zapobiegaj przełączeniu playlisty po kliknięciu usuń
                    deletePlaylist(name);
                });
                li.appendChild(deleteBtn);
            }

            li.addEventListener('click', () => {
                setActivePlaylist(name);
                togglePlaylistManager();
            });
            playlistManagerList.appendChild(li);
        });
    }


    // --- Główna logika inicjalizacji ---

    // Sprawdź, czy wróciliśmy od Spotify z kodem autoryzacyjnym
    const params = new URLSearchParams(window.location.search);
    const authorizationCode = params.get('code');

    if (authorizationCode) {
        // Wymień kod na token
        exchangeCodeForToken(authorizationCode).then(tokenData => {
            console.log("Uzyskano token Spotify!", tokenData);
            const accessToken = tokenData.access_token;
            
            initializeSpotifyPlayer(accessToken);
            loginSpotifyBtn.style.display = 'none';

            // Wyczyść parametry z adresu URL, aby nie były widoczne
            window.history.replaceState({}, document.title, "/Bubify/");
        });
    } else {
        console.log("Oczekiwanie na logowanie Spotify...");
    }

    function loadFromSpotify(token) {
        const fetchOptions = {
            headers: { 'Authorization': `Bearer ${token}` }
        };

        // 1. Pobierz polubione utwory
        const likedSongsPromise = fetch('https://api.spotify.com/v1/me/tracks?limit=50', fetchOptions)
            .then(res => res.json())
            .then(data => {
                if (!data || !data.items) {
                    console.error("Nie udało się pobrać polubionych utworów.", data);
                    return [];
                }
                const likedSongs = data.items.map(item => ({
                    title: item.track.name,
                    artist: item.track.artists.map(a => a.name).join(', '),
                    duration: formatTime(item.track.duration_ms / 1000),
                    duration_ms: item.track.duration_ms,
                    cover: item.track.album.images[0]?.url || 'https://placehold.co/100x100/2c2c2e/ffffff?text=?',
                    audio: item.track.uri,
                    isSpotify: true
                }));
                playlists['Polubione utwory'] = likedSongs; // Zapisz całe obiekty, nie tylko URI
                return likedSongs;
            });

        // 2. Pobierz playlisty użytkownika
        const playlistsPromise = fetch('https://api.spotify.com/v1/me/playlists', fetchOptions)
            .then(res => res.json())
            .then(data => {
                if (!data || !data.items) {
                    console.error("Nie udało się pobrać playlist użytkownika.", data);
                    return;
                }
                data.items.forEach(playlist => {
                    // Zapisujemy obietnicę wczytania utworów dla każdej playlisty
                    playlists[playlist.name] = fetch(playlist.tracks.href, fetchOptions)
                        .then(res => res.json())
                        .then(trackData => trackData.items.map(item => ({
                            title: item.track.name,
                            artist: item.track.artists.map(a => a.name).join(', '),
                            duration: formatTime(item.track.duration_ms / 1000),
                            duration_ms: item.track.duration_ms,
                            cover: item.track.album.images[0]?.url || 'https://placehold.co/100x100/2c2c2e/ffffff?text=?',
                            audio: item.track.uri,
                            isSpotify: true
                        })));
                });
            });

        // 3. Po załadowaniu obu, zaktualizuj UI
        // Używamy Promise.allSettled, aby kontynuować nawet jeśli jedno z zapytań się nie powiedzie
        // (np. błąd przy pobieraniu playlist nie powinien blokować wyświetlenia polubionych utworów)
        Promise.allSettled([likedSongsPromise, playlistsPromise])
            .then(([likedSongs]) => {
                // Połącz wszystkie unikalne utwory w jedną listę `allSongs`
                const allSongsMap = new Map();
                likedSongs.forEach(song => allSongsMap.set(song.audio, song));
                // W przyszłości można dodać utwory z innych playlist do allSongsMap
                allSongs = Array.from(allSongsMap.values());

                // Ustaw "Polubione utwory" jako domyślną playlistę
                setActivePlaylist('Polubione utwory');
            })
            .catch(err => {
                console.error("Błąd podczas pobierania danych ze Spotify:", err);
                // Obsługa wygaśnięcia tokenu
                if (err.status === 401 || (err.message && err.message.includes('401'))) {
                    window.location.hash = '';
                    loginSpotifyBtn.click();
                }
            });
    }

    function fetchSpotifyPlaylistTracks(playlistName) {
        const playlistData = playlists[playlistName];
        if (Array.isArray(playlistData)) {
            // Jeśli dane są już tablicą (np. dla "Polubione utwory"), zwróć je
            return Promise.resolve(playlistData);
        } else if (playlistData instanceof Promise) {
            // Jeśli to obietnica, poczekaj na jej rozwiązanie
            return playlistData;
        }
        return Promise.reject("Nie znaleziono playlisty");
    }

    function playSpotifyTrack(trackUri) {
        if (!spotifyDeviceId) {
            alert("Odtwarzacz Spotify nie jest jeszcze gotowy. Spróbuj ponownie za chwilę.");
            return;
        }
        fetch(`https://api.spotify.com/v1/me/player/play?device_id=${spotifyDeviceId}`, {
            method: 'PUT',
            body: JSON.stringify({ uris: [trackUri] }),
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${spotifyAccessToken}`
            },
        }).then(res => {
            if (res.status === 204) {
                console.log("Odtwarzanie utworu Spotify rozpoczęte.");
                isPlaying = true;
                body.classList.add('playing');
            } else {
                console.error("Nie udało się rozpocząć odtwarzania na Spotify.", res);
            }
        });
    }

    function updateSpotifyUI(state) {
        const currentTrack = state.track_window.current_track;
        document.querySelector('.song-title').textContent = currentTrack.name;
        document.querySelector('.song-artist').textContent = currentTrack.artists.map(a => a.name).join(', ');
        document.querySelector('.album-cover img').src = currentTrack.album.images[0].url;
    }

    function setActivePlaylist(name) {
        if (!playlists[name]) {
            console.error(`Playlista "${name}" nie istnieje.`);
            return;
        }
        activePlaylistName = name;
        playlistTitleEl.textContent = activePlaylistName;
        
        // Wyczyść listę piosenek i pokaż stan ładowania
        songListEl.innerHTML = '<li>Ładowanie...</li>';
        populatePlaylistManager(); // Zaktualizuj, która playlista jest aktywna

        fetchSpotifyPlaylistTracks(name).then(playlistSongs => {
            songs = playlistSongs;

            populatePlaylist();

            if (songs.length > 0) {
                loadSong(0);
                // Automatycznie odtwarzaj tylko przy pierwszym załadowaniu (Polubione utwory)
                if (name === 'Polubione utwory') {
                    playSong();
                }
            } else {
                // Wyczyść interfejs, jeśli playlista jest pusta
                document.querySelector('.song-title').textContent = 'Playlista jest pusta';
                document.querySelector('.song-artist').textContent = '...';
                document.querySelector('.album-cover img').src = 'https://placehold.co/100x100/2c2c2e/ffffff?text=?';
                durationEl.textContent = '0:00';
                currentTimeEl.textContent = '0:00';
                progress.style.width = '0%';
                if (spotifyPlayer) spotifyPlayer.pause();
                if (isPlaying) pauseSong();
            }
        }).catch(err => {
            console.error(`Nie udało się wczytać utworów dla playlisty "${name}":`, err);
            songListEl.innerHTML = '<li>Błąd wczytywania playlisty.</li>';
        });
    }

    function populatePlaylist() {
        songListEl.innerHTML = '';
        // W trybie Spotify, ulubione są już w swojej playliście, więc nie potrzebujemy `favoriteUrls`

        songs.forEach((song, index) => {
            const li = document.createElement('li');
            li.classList.add('song-item');

            li.innerHTML = `
                <div class="song-number">${index + 1}</div>
                <div class="song-thumbnail"><img src="${song.cover}" alt="Okładka"></div>
                <div class="song-item-info">
                    <div class="song-item-title">${song.title}</div>
                    <div class="song-item-artist">${song.artist}</div>
                </div>
                <div class="song-item-duration">${song.duration}</div>
                <div class="song-item-actions">
                    <!-- W trybie Spotify przycisk ulubionych można dodać w przyszłości -->
                </div>
            `;
            li.querySelector('.song-item-info').addEventListener('click', () => {
                currentSongIndex = index;
                loadSong(currentSongIndex);
                playSong();
                body.classList.remove('queue-open'); // Dodatkowo zamyka kolejkę po wyborze utworu
                queueBtn.classList.remove('active');
            });
            songListEl.appendChild(li);
        });
    }

    function loadSong(index) {
        if (!songs[index]) return;
        const song = songs[index];
        document.querySelector('.song-title').textContent = song.title;
        document.querySelector('.song-artist').textContent = song.artist;
        document.querySelector('.album-cover img').src = song.cover;
        
        // Dla Spotify, czas trwania jest ustawiany przez player_state_changed,
        // ale ustawmy go też tutaj dla spójności przy pierwszym ładowaniu.
        if (song.isSpotify) {
            durationEl.textContent = formatTime(song.duration_ms / 1000);
        } else {
            durationEl.textContent = song.duration;
        }


        if (song.isSpotify) {
            // Dla Spotify nie ustawiamy audio.src, bo odtwarzanie jest obsługiwane przez API
            audio.src = ''; // Wyczyść źródło, aby uniknąć konfliktów
        } else {
            // Stara logika dla plików mp3
            audio.src = song.audio;
        }

        // Sprawdzenie artysty i dodanie/usunięcie klasy dla cienia
        albumCover.classList.remove('type-o-negative-glow', 'rammstein-glow');
        
        const artistLower = song.artist.toLowerCase();
        if (artistLower.includes('type o negative')) {
            albumCover.classList.add('type-o-negative-glow');
        } else if (artistLower.includes('rammstein')) {
            albumCover.classList.add('rammstein-glow');
        }

        document.querySelectorAll('.song-item').forEach(item => item.classList.remove('active'));
        document.querySelector(`.song-item:nth-child(${index + 1})`)?.classList.add('active');

        // Zresetuj i potencjalnie rozpocznij animację obrotu dla nowego utworu
        cancelAnimationFrame(animationFrameId);
        currentRotation = 0;
        albumCover.style.transform = 'rotate(0deg)';
        if (isPlaying) {
            animationFrameId = requestAnimationFrame(rotateCover);
        }

        // Aktualizacja metadanych dla Media Session API - Chodzi o okładkę na panelu powiadomień
        if ('mediaSession' in navigator) {
            navigator.mediaSession.metadata = new MediaMetadata({
                title: item.track.name,
                artist: item.track.artists.map(a => a.name).join(', '),
                title: song.title,
                artist: song.artist,
                album: 'Bubify',
                artwork: [
                    { src: song.cover, sizes: '96x96', type: 'image/jpeg' },
                    { src: song.cover, sizes: '512x512', type: 'image/jpeg' },
                ]
            });
        }
    }

    function togglePlay() {
        if(isPlaying) pauseSong(); else playSong();
    }

    function playSong() {
        const song = songs[currentSongIndex];
        if (!song) return;

        if (song.isSpotify) {
            playSpotifyTrack(song.audio);
        } else {
            if(!audio.src) return;
            isPlaying = true;
            body.classList.add('playing');
            cancelAnimationFrame(animationFrameId);
            animationFrameId = requestAnimationFrame(rotateCover);
            audio.play();
            if ('mediaSession' in navigator) {
                navigator.mediaSession.playbackState = "playing";
            }
        }
    }

    function pauseSong() {
        const song = songs[currentSongIndex];
        if (!song) return;

        if (song.isSpotify) {
            if (spotifyPlayer) {
                spotifyPlayer.pause().then(() => {
                    console.log('Zapauzowano odtwarzanie Spotify.');
                    isPlaying = false;
                    body.classList.remove('playing');
                });
            }
        } else {
            isPlaying = false;
            body.classList.remove('playing');
            cancelAnimationFrame(animationFrameId);
            audio.pause();
            if ('mediaSession' in navigator) {
                navigator.mediaSession.playbackState = "paused";
            }
        }
    }

    function nextSong() {
        if (songs.length === 0) return;

        if (songs[currentSongIndex]?.isSpotify && spotifyPlayer) {
            spotifyPlayer.nextTrack().then(() => console.log('Przełączono na następny utwór Spotify.'));
        } else {
            currentSongIndex = (currentSongIndex + 1) % songs.length;
            loadSong(currentSongIndex);
            if (isPlaying) playSong();
        }
    }

    function prevSong() {
        if (songs.length === 0) return;

        // Dla Spotify, API samo decyduje, czy cofnąć utwór, czy przejść do poprzedniego
        if (songs[currentSongIndex]?.isSpotify && spotifyPlayer) { 
            spotifyPlayer.previousTrack().then(() => console.log('Poprzedni utwór Spotify.'));
            return;
        }
        if (songs.length === 0) return;
        currentSongIndex = (currentSongIndex - 1 + songs.length) % songs.length;
        loadSong(currentSongIndex);
        if(isPlaying) playSong();
    }

    function fetchAlbumCovers() {
        if (spotifyAccessToken || songs[0]?.isSpotify) return; // Nie pobieraj z iTunes, jeśli mamy dane ze Spotify
        allSongs.forEach((song, index) => {
            if (song.artist === 'Nieznany artysta') return;

            const searchTerm = encodeURIComponent(`${song.artist} ${song.title}`);
            const url = `https://itunes.apple.com/search?term=${searchTerm}&entity=song&limit=1`;

            fetch(url)
                .then(res => res.json())
                .then(data => {
                    if (data.results && data.results.length > 0) {
                        const coverUrl = data.results[0].artworkUrl100.replace('100x100', '600x600');
                        allSongs[index].cover = coverUrl;

                        if (index === currentSongIndex) {
                            document.querySelector('.album-cover img').src = coverUrl;
                            // Zaktualizuj również okładkę w Media Session
                            if ('mediaSession' in navigator && navigator.mediaSession.metadata) {
                                navigator.mediaSession.metadata.artwork = [
                                    { src: coverUrl, sizes: '96x96', type: 'image/jpeg' },
                                    { src: coverUrl, sizes: '512x512', type: 'image/jpeg' },
                                ];
                            }
                        }
                        const songItem = songListEl.querySelector(`.song-item:nth-child(${index + 1})`);
                        if (songItem) {
                            songItem.querySelector('.song-thumbnail img').src = coverUrl;
                        }
                    }
                })
                .catch(err => console.warn(`Nie udało się pobrać okładki dla: ${song.title}`, err));
        });
    }

    function toggleFavorite(songToToggle) {
        const favoritePlaylist = playlists['Ulubione'];
        const songUrl = songToToggle.audio;
        const songIndexInFavorites = favoritePlaylist.indexOf(songUrl);

        if (songIndexInFavorites > -1) {
            favoritePlaylist.splice(songIndexInFavorites, 1);
        } else {
            favoritePlaylist.push(songUrl);
        }
        
        savePlaylists();
        // Odśwież widok, aby zaktualizować serduszka
        populatePlaylist();
    }

    function toggleQueue() {
        body.classList.toggle('queue-open');
        queueBtn.classList.toggle('active');
    }

    function cycleRepeatMode() {
        repeatMode = (repeatMode + 1) % 3;
        updateRepeatUI();
    }

    function updateRepeatUI() {
        if (repeatMode === 0) { // None
            repeatBtn.classList.remove('active');
            iconRepeatAll.style.display = 'block';
            iconRepeatOne.style.display = 'none';
        } else if (repeatMode === 1) { // All
            repeatBtn.classList.add('active');
            iconRepeatAll.style.display = 'block';
            iconRepeatOne.style.display = 'none';
        } else { // One (repeatMode === 2)
            iconRepeatAll.style.display = 'none';
            iconRepeatOne.style.display = 'block';
        }
    }

    function rotateCover() {
        if (!isPlaying) return;
        currentRotation += 0.1; // Dostosuj prędkość obrotu
        albumCover.style.transform = `rotate(${currentRotation}deg)`;
        animationFrameId = requestAnimationFrame(rotateCover);
    }

    function updateVolumeSlider() {
        const percentage = (volumeSlider.value - volumeSlider.min) / (volumeSlider.max - volumeSlider.min) * 100;
        volumeSlider.style.setProperty('--volume-progress', `${percentage}%`);
    }

    // --- Funkcjonalność przewijania (skreczowania) na desktop i mobile ---
    let isScrubbing = false;
    let wasPlayingBeforeScrub = false;
    let albumCoverCenterX, albumCoverCenterY;
    let lastAngle = 0;

    function handleScrubStart(e) {
        if (!audio.duration) return;
        e.preventDefault(); // Zapobiega domyślnym akcjom, np. zaznaczaniu tekstu lub przewijaniu strony na mobile

        isScrubbing = true;
        wasPlayingBeforeScrub = isPlaying;
        if (wasPlayingBeforeScrub) {
            pauseSong();
        }

        // Oblicz środek okładki
        const rect = albumCover.getBoundingClientRect();
        albumCoverCenterX = rect.left + rect.width / 2;
        albumCoverCenterY = rect.top + rect.height / 2;

        // Pobierz pozycję wskaźnika (mysz lub dotyk)
        const pointerX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
        const pointerY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;

        // Ustaw kąt początkowy do obliczania różnicy w ruchu
        lastAngle = Math.atan2(pointerY - albumCoverCenterY, pointerX - albumCoverCenterX);

        body.classList.add('scrubbing');
        progress.style.transition = 'none'; // Wyłącz płynną animację paska postępu dla natychmiastowej reakcji
    }

    function handleScrubMove(e) {
        if (!isScrubbing) return;
        e.preventDefault();

        const pointerX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
        const pointerY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;

        const currentAngle = Math.atan2(pointerY - albumCoverCenterY, pointerX - albumCoverCenterX);
        let deltaAngle = currentAngle - lastAngle;

        // Poprawka na "przeskakiwanie" kąta z +180 na -180 stopni i odwrotnie
        if (deltaAngle > Math.PI) deltaAngle -= 2 * Math.PI;
        if (deltaAngle < -Math.PI) deltaAngle += 2 * Math.PI;

        const deltaAngleDeg = deltaAngle * (180 / Math.PI);

        // Zaktualizuj obrót wizualny, dodając zmianę
        currentRotation += deltaAngleDeg;
        albumCover.style.transform = `rotate(${currentRotation}deg)`;

        // Zaktualizuj czas utworu na podstawie zmiany kąta
        const timePerDegree = 15 / 360; // Czułość: 15 sekund utworu na pełny obrót (360 stopni)
        const timeChange = deltaAngleDeg * timePerDegree;
        let newTime = audio.currentTime + timeChange;
        if (newTime < 0) newTime = 0;
        if (newTime > audio.duration) newTime = audio.duration;
        audio.currentTime = newTime;

        // Zapisz aktualny kąt na potrzeby następnego ruchu
        lastAngle = currentAngle;
    }

    function handleScrubEnd() {
        if (!isScrubbing) return;
        isScrubbing = false;
        body.classList.remove('scrubbing');
        progress.style.transition = 'width 0.1s linear'; // Włącz ponownie animację paska
        if (wasPlayingBeforeScrub) playSong();
    }

    // --- Funkcjonalność przewijania (skreczowania) na PASKU POSTĘPU ---
    let isProgressScrubbing = false;

    function setSongPosition(e) {
        const song = songs[currentSongIndex];
        if (!song || (!audio.duration && !song.isSpotify)) return;

        if (songs[currentSongIndex]?.isSpotify && spotifyPlayer) {
            const rect = progressBar.getBoundingClientRect();
            const newPosition = ((e.type.startsWith('touch') ? e.touches[0].clientX : e.clientX) - rect.left) / rect.width;
            spotifyPlayer.seek(newPosition * song.duration_ms).then(() => console.log('Przewinięto utwór Spotify.'));
        }
        const rect = progressBar.getBoundingClientRect();
        // Dla zdarzeń dotykowych użyj pierwszego punktu dotyku
        const clientX = e.type.startsWith('touch') ? e.touches[0].clientX : e.clientX;
        const offsetX = clientX - rect.left;
        const width = rect.width;
        let newTime = (offsetX / width) * audio.duration;

        // Ogranicz wartość do zakresu od 0 do czasu trwania utworu
        if (newTime < 0) newTime = 0;
        if (newTime > audio.duration) newTime = audio.duration;

        audio.currentTime = newTime;
    }

    function handleProgressScrubStart(e) {
        e.preventDefault();
        isProgressScrubbing = true;
        progress.style.transition = 'none'; // Wyłącz płynną animację dla natychmiastowej reakcji
        body.classList.add('scrubbing');
        setSongPosition(e); // Ustaw pozycję od razu po kliknięciu
    }

    function handleProgressScrubMove(e) {
        if (!isProgressScrubbing) return;
        e.preventDefault();
        setSongPosition(e);
    }

    function handleProgressScrubEnd() {
        if (!isProgressScrubbing) return;
        isProgressScrubbing = false;
        progress.style.transition = 'width 0.1s linear'; // Włącz ponownie animację paska
        body.classList.remove('scrubbing');
    }

    // Dodanie nasłuchiwaczy dla paska postępu (zastępuje stary 'click')
    progressBar.addEventListener('mousedown', handleProgressScrubStart);
    progressBar.addEventListener('touchstart', handleProgressScrubStart, { passive: false });

    // Nasłuchiwacze na całym dokumencie, aby przeciąganie działało płynnie
    document.addEventListener('mousemove', handleProgressScrubMove);
    document.addEventListener('touchmove', handleProgressScrubMove, { passive: false });

    document.addEventListener('mouseup', handleProgressScrubEnd);
    document.addEventListener('touchend', handleProgressScrubEnd);

    audio.addEventListener('timeupdate', () => {
        if (songs[currentSongIndex]?.isSpotify) return; // Aktualizacje dla Spotify idą przez `player_state_changed`
        if(!audio.duration) return;
        const progressPercent = (audio.currentTime/audio.duration)*100;
        progress.style.width = `${progressPercent}%`;

        currentTimeEl.textContent = formatTime(audio.currentTime);
    });

    audio.addEventListener('loadedmetadata', () => {
        if (songs[currentSongIndex]?.isSpotify) return;
        if (audio.duration) {
            const formattedDuration = formatTime(audio.duration);
            durationEl.textContent = formattedDuration;
            
            if (songs[currentSongIndex]) {
                songs[currentSongIndex].duration = formattedDuration;
                const songItem = songListEl.querySelector(`.song-item:nth-child(${currentSongIndex + 1})`);
                if (songItem) songItem.querySelector('.song-item-duration').textContent = formattedDuration;
            }
        }
    });

    audio.addEventListener('ended', () => {
        if (songs[currentSongIndex]?.isSpotify) return; // Spotify samo przejdzie do następnego utworu
        if (repeatMode === 2) { // Powtarzaj jeden
            audio.currentTime = 0;
            playSong();
        } else if (repeatMode === 1) { // Powtarzaj wszystko
            nextSong();
        } else { // Bez powtarzania
            if (currentSongIndex < songs.length - 1) {
                nextSong();
            } else {
                // Koniec listy, zatrzymaj odtwarzanie
                pauseSong();
                audio.currentTime = 0;
            }
        }
    });
    playBtn.addEventListener('click', togglePlay);
    document.querySelector('.prev-btn').addEventListener('click', prevSong);
    document.querySelector('.next-btn').addEventListener('click', nextSong);
    queueBtn.addEventListener('click', toggleQueue);
    repeatBtn.addEventListener('click', cycleRepeatMode);
    managePlaylistsBtn.addEventListener('click', togglePlaylistManager);
    closePlaylistManagerBtn.addEventListener('click', togglePlaylistManager);

    // Zdarzenia dla nowego modala tworzenia playlisty
    createPlaylistBtn.addEventListener('click', createPlaylist);
    cancelCreatePlaylistBtn.addEventListener('click', hideCreatePlaylistModal);
    confirmCreatePlaylistBtn.addEventListener('click', handleConfirmCreatePlaylist);
    createPlaylistModalOverlay.addEventListener('click', (e) => {
        if (e.target === createPlaylistModalOverlay) { // Zamykanie po kliknięciu w tło
            hideCreatePlaylistModal();
        }
    });
    newPlaylistNameInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') handleConfirmCreatePlaylist(); });

    volumeSlider.addEventListener('input', (e) => {
        const volume = e.target.value / 100;
        if (songs[currentSongIndex]?.isSpotify && spotifyPlayer) {
            spotifyPlayer.setVolume(volume).then(() => console.log(`Głośność Spotify ustawiona na ${volume}`));
        } else {
            audio.volume = volume;
        }
        updateVolumeSlider();
    });
    audio.volume = volumeSlider.value / 100;
    updateVolumeSlider();

    // Nasłuchiwanie na zdarzenia myszy i dotyku dla okładki
    albumCover.addEventListener('mousedown', handleScrubStart);
    albumCover.addEventListener('touchstart', handleScrubStart, { passive: false });

    // Nasłuchiwanie na całym dokumencie, aby przeciąganie działało nawet po wyjechaniu kursorem/palcem poza okładkę
    document.addEventListener('mousemove', handleScrubMove);
    document.addEventListener('touchmove', handleScrubMove, { passive: false });

    document.addEventListener('mouseup', handleScrubEnd);
    document.addEventListener('touchend', handleScrubEnd);

    // Integracja z Media Session API (sterowanie z belki systemowej / ekranu blokady)
    if ('mediaSession' in navigator) {
        navigator.mediaSession.setActionHandler('play', playSong);
        navigator.mediaSession.setActionHandler('pause', pauseSong);
        navigator.mediaSession.setActionHandler('previoustrack', prevSong);
        navigator.mediaSession.setActionHandler('nexttrack', nextSong);
    }

});
</script>
</body>
</html>
